
/*
    [힙 - 스택 - 큐]

        아래 코드의 예상 순서는 2, 4, 6일 것 같지만, 2, 6, 4가 된다.
        이렇게 js는 코드 위에서 적든, 밑에 적든, 빠른 것부터 실행해준다.
        이 이유를 이해하려면 JS가 브라우져에서 동작하는 원리를 알아야 한다.

        1. 웹브라우져는 다음과 같은 공간들이 있다.
            Heap : i = { age: 20 }, j = { name: 'kim' } 과 같이 변수를 담아두는 공간이다.
            Stack : 코드를 실행해주는 곳. 단, 코드 한줄씩만 들어간다. (그래서 js는 보통 single threaded language라고 한다.)
                즉, 여기서, setTimeout 이하의 함수는 1초 뒤에 실행을 해줘야 하기 때문에 stack에 넣지 않고 대기실로 보낸다.
            대기실 : 대기시간이 끝나면, que라는 대기실로 넘겨준다.
                대기실 보내는 코드들 : async function (ajax 요청코드, 이벤트리스너, setTimeout 등)
            Que(ue) : 처리가 완료된 코드들을 줄을 세워서 stack으로 하나씩 올려보내준다.
                단, stack이 비어있을 때만 올려보낸다.
        2. js에는 10초 이상 걸리는 어려운 연산을 넣으면 안된다.
            예를 들어, 천만번 반복 계산하는 for문 같은 것이 stack을 채우게 되면, 
            그동안 js기반 사용자 기능이 (버튼 누르면 모달창 띄워주는 이벤트리스너 등등) 모두 동작을 하지 않는다.
            stack이 비었을 때만 que에 있는 동작을 올려보내기 때문이다.
            그래서 "응답 대기중입니다" 메시지 같은, 브라우져 프리징을 띄운다.
            stack을 바쁘게 하지말기. queue를 바쁘게 하지 말기. 이 두 가지가 중요하다.
*/

console.log(1+1)
setTimeout(function () { console.log(2+2) }, 1000) // 1초 뒤 실행
console.log(3+3)

