<!DOCTYPE html>
<!-- saved from url=(0041)https://react.vlpt.us/basic/23-immer.html -->
<html lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style><style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style><style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style><style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style>


<title>23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="">
<meta name="generator" content="GitBook 3.2.3">
<link rel="stylesheet" href="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/style.css">
<link rel="stylesheet" href="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/collapsible-chapters.css">
<link rel="stylesheet" href="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/website.css">
<link rel="stylesheet" href="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/search.css">
<link rel="stylesheet" href="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/website(1).css">
<meta name="HandheldFriendly" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://react.vlpt.us/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="https://react.vlpt.us/gitbook/images/favicon.ico" type="image/x-icon">


<link rel="prev" href="https://react.vlpt.us/basic/22-context-dispatch.html"><link rel="next" href="https://react.vlpt.us/basic/24-class-component.html"></head>
<body>
<div class="book without-animation with-summary">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search">
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter expanded" data-level="1.1" data-path="../">
<a href="https://react.vlpt.us/">
벨로퍼트와 함께하는 모던 리액트
</a>
</li>
<li class="chapter expanded" data-level="1.2" data-path="./">
<a href="https://react.vlpt.us/basic/">
1장. 리액트 입문
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter " data-level="1.2.1" data-path="01-concept.html">
<a href="https://react.vlpt.us/basic/01-concept.html">
1. 리액트는 어쩌다가 만들어졌을까?
</a>
</li>
<li class="chapter " data-level="1.2.2" data-path="02-prepare.html">
<a href="https://react.vlpt.us/basic/02-prepare.html">
2. 작업환경 준비
</a>
</li>
<li class="chapter " data-level="1.2.3" data-path="03-first-component.html">
<a href="https://react.vlpt.us/basic/03-first-component.html">
3. 나의 첫번째 리액트 컴포넌트
</a>
</li>
<li class="chapter " data-level="1.2.4" data-path="04-jsx.html">
<a href="https://react.vlpt.us/basic/04-jsx.html">
4. JSX
</a>
</li>
<li class="chapter " data-level="1.2.5" data-path="05-props.html">
<a href="https://react.vlpt.us/basic/05-props.html">
5. props 를 통해 컴포넌트에게 값 전달하기
</a>
</li>
<li class="chapter " data-level="1.2.6" data-path="06-conditional-rendering.html">
<a href="https://react.vlpt.us/basic/06-conditional-rendering.html">
6. 조건부 렌더링
</a>
</li>
<li class="chapter " data-level="1.2.7" data-path="07-useState.html">
<a href="https://react.vlpt.us/basic/07-useState.html">
7. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기
</a>
</li>
<li class="chapter " data-level="1.2.8" data-path="08-manage-input.html">
<a href="https://react.vlpt.us/basic/08-manage-input.html">
8. input 상태 관리하기
</a>
</li>
<li class="chapter " data-level="1.2.9" data-path="09-multiple-inputs.html">
<a href="https://react.vlpt.us/basic/09-multiple-inputs.html">
9. 여러개의 input 상태 관리하기
</a>
</li>
<li class="chapter " data-level="1.2.10" data-path="10-useRef.html">
<a href="https://react.vlpt.us/basic/10-useRef.html">
10. useRef 로 특정 DOM 선택하기
</a>
</li>
<li class="chapter " data-level="1.2.11" data-path="11-render-array.html">
<a href="https://react.vlpt.us/basic/11-render-array.html">
11. 배열 렌더링하기
</a>
</li>
<li class="chapter " data-level="1.2.12" data-path="12-variable-with-useRef.html">
<a href="https://react.vlpt.us/basic/12-variable-with-useRef.html">
12. useRef 로 useRef 로 컴포넌트 안의 변수 만들기
</a>
</li>
<li class="chapter " data-level="1.2.13" data-path="13-array-insert.html">
<a href="https://react.vlpt.us/basic/13-array-insert.html">
13. 배열에 항목 추가하기
</a>
</li>
<li class="chapter " data-level="1.2.14" data-path="14-array-remove.html">
<a href="https://react.vlpt.us/basic/14-array-remove.html">
14. 배열에 항목 제거하기
</a>
</li>
<li class="chapter " data-level="1.2.15" data-path="15-array-modify.html">
<a href="https://react.vlpt.us/basic/15-array-modify.html">
15. 배열에 항목 수정하기
</a>
</li>
<li class="chapter " data-level="1.2.16" data-path="16-useEffect.html">
<a href="https://react.vlpt.us/basic/16-useEffect.html">
16. useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기
</a>
</li>
<li class="chapter " data-level="1.2.17" data-path="17-useMemo.html">
<a href="https://react.vlpt.us/basic/17-useMemo.html">
17. useMemo 를 사용하여 연산한 값 재사용하기
</a>
</li>
<li class="chapter " data-level="1.2.18" data-path="18-useCallback.html">
<a href="https://react.vlpt.us/basic/18-useCallback.html">
18. useCallback 를 사용하여 함수 재사용하기
</a>
</li>
<li class="chapter " data-level="1.2.19" data-path="19-React.memo.html">
<a href="https://react.vlpt.us/basic/19-React.memo.html">
19. React.memo 를 사용한 컴포넌트 리렌더링 방지
</a>
</li>
<li class="chapter " data-level="1.2.20" data-path="20-useReducer.html">
<a href="https://react.vlpt.us/basic/20-useReducer.html">
20. useReducer 를 사용하여 상태 업데이트 로직 분리하기
</a>
</li>
<li class="chapter " data-level="1.2.21" data-path="21-custom-hook.html">
<a href="https://react.vlpt.us/basic/21-custom-hook.html">
21. 커스텀 Hooks 만들기
</a>
</li>
<li class="chapter " data-level="1.2.22" data-path="22-context-dispatch.html">
<a href="https://react.vlpt.us/basic/22-context-dispatch.html">
22. Context API 를 사용한 전역 값 관리
</a>
</li>
<li class="chapter active expanded" data-level="1.2.23" data-path="23-immer.html">
<a href="https://react.vlpt.us/basic/23-immer.html">
23. Immer 를 사용한 더 쉬운 불변성 관리
</a>
</li>
<li class="chapter expanded" data-level="1.2.24" data-path="24-class-component.html">
<a href="https://react.vlpt.us/basic/24-class-component.html">
24. 클래스형 컴포넌트
</a>
</li>
<li class="chapter " data-level="1.2.25" data-path="25-lifecycle.html">
<a href="https://react.vlpt.us/basic/25-lifecycle.html">
25. LifeCycle Method
</a>
</li>
<li class="chapter " data-level="1.2.26" data-path="26-componentDidCatch-and-sentry.html">
<a href="https://react.vlpt.us/basic/26-componentDidCatch-and-sentry.html">
26. componentDidCatch 로 에러 잡아내기 / Sentry 연동
</a>
</li>
<li class="chapter expanded" data-level="1.2.27" data-path="27-useful-tools.html">
<a href="https://react.vlpt.us/basic/27-useful-tools.html">
27. 리액트 개발 할 때 사용하면 편리한 도구들 - Prettier, ESLint, Snippet
</a>
 </li>
<li class="chapter " data-level="1.2.28" data-path="CONCLUSION.html">
<a href="https://react.vlpt.us/basic/CONCLUSION.html">
리액트 입문 마무리
</a>
</li>
</ul>
</li>
<li class="chapter " data-level="1.3" data-path="../styling/">
<a href="https://react.vlpt.us/styling/">
2장. 리액트 컴포넌트 스타일링하기
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.3.1" data-path="../styling/01-sass.html">
<a href="https://react.vlpt.us/styling/01-sass.html">
1. Sass
</a>
</li>
<li class="chapter expanded" data-level="1.3.2" data-path="../styling/02-css-module.html">
<a href="https://react.vlpt.us/styling/02-css-module.html">
2. CSS Module
</a>
</li>
<li class="chapter expanded" data-level="1.3.3" data-path="../styling/03-styled-components.html">
<a href="https://react.vlpt.us/styling/03-styled-components.html">
3. styled-components
</a>
</li>
<li class="chapter expanded" data-level="1.3.4" data-path="../styling/CONCLUSION.html">
<a href="https://react.vlpt.us/styling/CONCLUSION.html">
정리
</a>
</li>
</ul>
</li>
<li class="chapter " data-level="1.4" data-path="../mashup-todolist/">
<a href="https://react.vlpt.us/mashup-todolist/">
3장. 멋진 투두리스트 만들기
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.4.1" data-path="../mashup-todolist/01-create-components.html">
<a href="https://react.vlpt.us/mashup-todolist/01-create-components.html">
1. 컴포넌트 만들기
</a>
</li>
<li class="chapter expanded" data-level="1.4.2" data-path="../mashup-todolist/02-manage-state.html">
<a href="https://react.vlpt.us/mashup-todolist/02-manage-state.html">
2. Context API를 활용한 상태 관리
</a>
</li>
<li class="chapter expanded" data-level="1.4.3" data-path="../mashup-todolist/03-implement.html">
<a href="https://react.vlpt.us/mashup-todolist/03-implement.html">
3. 기능 구현하기
</a>
</li>
</ul>
</li>
<li class="chapter " data-level="1.5" data-path="../integrate-api/">
<a href="https://react.vlpt.us/integrate-api/">
4장. API 연동하기
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.5.1" data-path="../integrate-api/01-basic.html">
<a href="https://react.vlpt.us/integrate-api/01-basic.html">
1. API 연동의 기본
</a>
</li>
<li class="chapter expanded" data-level="1.5.2" data-path="../integrate-api/02-useReducer.html">
<a href="https://react.vlpt.us/integrate-api/02-useReducer.html">
2. useReducer 로 요청 상태 관리하기
</a>
</li>
<li class="chapter expanded" data-level="1.5.3" data-path="../integrate-api/03-useAsync.html">
<a href="https://react.vlpt.us/integrate-api/03-useAsync.html">
3. useAsync 커스텀 Hook 만들어서 사용하기
</a>
</li>
<li class="chapter expanded" data-level="1.5.4" data-path="../integrate-api/04-react-async.html">
<a href="https://react.vlpt.us/integrate-api/04-react-async.html">
4. react-async 로 요청 상태 관리하기
</a>
</li>
<li class="chapter expanded" data-level="1.5.5" data-path="../integrate-api/05-using-with-context.html">
<a href="https://react.vlpt.us/integrate-api/05-using-with-context.html">
5. Context 와 함께 사용하기
</a>
</li>
<li class="chapter expanded" data-level="1.5.6" data-path="../integrate-api/CONCLUSION.html">
<a href="https://react.vlpt.us/integrate-api/CONCLUSION.html">
정리
</a>
</li>
</ul>
</li>
<li class="chapter " data-level="1.6" data-path="../react-router/">
<a href="https://react.vlpt.us/react-router/">
5장. 리액트 라우터
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.6.1" data-path="../react-router/01-concepts.html">
<a href="https://react.vlpt.us/react-router/01-concepts.html">
1. 프로젝트 준비 및 기본적인 사용법
</a>
</li>
<li class="chapter expanded" data-level="1.6.2" data-path="../react-router/02-params-and-query.html">
<a href="https://react.vlpt.us/react-router/02-params-and-query.html">
2. 파라미터와 쿼리
</a>
</li>
<li class="chapter expanded" data-level="1.6.3" data-path="../react-router/03-subroutes.html">
<a href="https://react.vlpt.us/react-router/03-subroutes.html">
3. 서브라우트
</a>
</li>
<li class="chapter expanded" data-level="1.6.4" data-path="../react-router/04-extra.html">
<a href="https://react.vlpt.us/react-router/04-extra.html">
4. 리액트 라우터 부가기능
</a>
</li>
<li class="chapter expanded" data-level="1.6.5" data-path="../react-router/05-use-router-hook.html">
<a href="https://react.vlpt.us/react-router/05-use-router-hook.html">
5. useReactRouter Hook 사용하기
</a>
</li>
</ul>
</li>
<li class="chapter expanded" data-level="1.7" data-path="../redux/">
<a href="https://react.vlpt.us/redux/">
6장. 리덕스
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.7.1" data-path="../redux/01-keywords.html">
<a href="https://react.vlpt.us/redux/01-keywords.html">
1. 리덕스에서 사용되는 키워드 숙지하기
</a>
</li>
<li class="chapter " data-level="1.7.2" data-path="../redux/02-rules.html">
<a href="https://react.vlpt.us/redux/02-rules.html">
2. 리덕스의 3가지 규칙
</a>
</li>
<li class="chapter " data-level="1.7.3" data-path="../redux/03-prepare.html">
<a href="https://react.vlpt.us/redux/03-prepare.html">
3. 리덕스 사용 할 준비하기
</a>
</li>
<li class="chapter " data-level="1.7.4" data-path="../redux/04-make-modules.html">
<a href="https://react.vlpt.us/redux/04-make-modules.html">
4. 리덕스 모듈 만들기
</a>
</li>
<li class="chapter " data-level="1.7.5" data-path="../redux/05-counter.html">
<a href="https://react.vlpt.us/redux/05-counter.html">
5. 카운터 구현하기
</a>
</li>
<li class="chapter " data-level="1.7.6" data-path="../redux/06-redux-devtools.html">
<a href="https://react.vlpt.us/redux/06-redux-devtools.html">
6. 리덕스 개발자도구 적용하기
</a>
</li>
<li class="chapter " data-level="1.7.7" data-path="../redux/07-implement-todos.html">
<a href="https://react.vlpt.us/redux/07-implement-todos.html">
7. 할 일 목록 구현하기
</a>
</li>
<li class="chapter " data-level="1.7.8" data-path="../redux/08-optimize-useSelector.html">
<a href="https://react.vlpt.us/redux/08-optimize-useSelector.html">
8. useSelector 최적화
</a>
</li>
<li class="chapter " data-level="1.7.9" data-path="../redux/09-connect.html">
<a href="https://react.vlpt.us/redux/09-connect.html">
9. connect 함수
</a>
</li>
<li class="chapter expanded" data-level="1.7.10" data-path="../redux/CONCLUSION.html">
<a href="https://react.vlpt.us/redux/CONCLUSION.html">
정리
</a>
</li>
</ul>
</li>
<li class="chapter expanded" data-level="1.8" data-path="../redux-middleware/">
<a href="https://react.vlpt.us/redux-middleware/">
7장. 리덕스 미들웨어
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.8.1" data-path="../redux-middleware/01-prepare.html">
<a href="https://react.vlpt.us/redux-middleware/01-prepare.html">
1. 리덕스 프로젝트 준비하기
</a>
</li>
<li class="chapter expanded" data-level="1.8.2" data-path="../redux-middleware/02-make-middleware.html">
<a href="https://react.vlpt.us/redux-middleware/02-make-middleware.html">
2. 미들웨어 만들어보고 이해하기
</a>
</li>
<li class="chapter expanded" data-level="1.8.3" data-path="../redux-middleware/03-logger-and-devtools.html">
<a href="https://react.vlpt.us/redux-middleware/03-logger-and-devtools.html">
3. redux-logger 사용 및 미들웨어와 DevTools 함께 사용하기
</a>
</li>
<li class="chapter " data-level="1.8.4" data-path="../redux-middleware/04-redux-thunk.html">
<a href="https://react.vlpt.us/redux-middleware/04-redux-thunk.html">
4. redux-thunk
</a>
</li>
<li class="chapter " data-level="1.8.5" data-path="../redux-middleware/05-redux-thunk-with-promise.html">
<a href="https://react.vlpt.us/redux-middleware/05-redux-thunk-with-promise.html">
5. redux-thunk로 프로미스 다루기
</a>
</li>
<li class="chapter " data-level="1.8.6" data-path="../redux-middleware/06-fix-reloading.html">
<a href="https://react.vlpt.us/redux-middleware/06-fix-reloading.html">
6. API 재로딩 문제 해결하기
</a>
</li>
<li class="chapter " data-level="1.8.7" data-path="../redux-middleware/07-router-with-thunk.html">
<a href="https://react.vlpt.us/redux-middleware/07-router-with-thunk.html">
7. thunk에서 라우터 연동하기
</a>
</li>
<li class="chapter " data-level="1.8.8" data-path="../redux-middleware/08-json-server.html">
<a href="https://react.vlpt.us/redux-middleware/08-json-server.html">
8. json-server
</a>
</li>
<li class="chapter " data-level="1.8.9" data-path="../redux-middleware/09-cors-and-proxy.html">
<a href="https://react.vlpt.us/redux-middleware/09-cors-and-proxy.html">
9. CORS 와 Webpack DevServer Proxy
</a>
</li>
<li class="chapter " data-level="1.8.10" data-path="../redux-middleware/10-redux-saga.html">
<a href="https://react.vlpt.us/redux-middleware/10-redux-saga.html">
10. redux-saga
</a>
</li>
<li class="chapter " data-level="1.8.11" data-path="../redux-middleware/11-redux-saga-with-promise.html">
<a href="https://react.vlpt.us/redux-middleware/11-redux-saga-with-promise.html">
11. redux-saga 로 프로미스 다루기
</a>
</li>
<li class="chapter " data-level="1.8.12" data-path="../redux-middleware/12-redux-saga-with-router.html">
<a href="https://react.vlpt.us/redux-middleware/12-redux-saga-with-router.html">
12. saga에서 라우터 연동하기
</a>
</li>
<li class="chapter expanded" data-level="1.8.13" data-path="../redux-middleware/CONCLUSION.html">
<a href="https://react.vlpt.us/redux-middleware/CONCLUSION.html">
 정리
</a>
</li>
</ul>
</li>
<li class="chapter expanded" data-level="1.9" data-path="../using-typescript/">
<a href="https://react.vlpt.us/using-typescript/">
8장. 리액트 프로젝트에서 타입스크립트 사용하기
<i class="exc-trigger fa"></i></a>
<ul class="articles">
<li class="chapter expanded" data-level="1.9.1" data-path="../using-typescript/01-practice.html">
<a href="https://react.vlpt.us/using-typescript/01-practice.html">
1. 타입스크립트 연습
</a>
</li>
<li class="chapter expanded" data-level="1.9.2" data-path="../using-typescript/02-ts-react-basic.html">
<a href="https://react.vlpt.us/using-typescript/02-ts-react-basic.html">
2. 리액트 컴포넌트 타입스크립트로 작성하기
</a>
</li>
<li class="chapter expanded" data-level="1.9.3" data-path="../using-typescript/03-ts-manage-state.html">
<a href="https://react.vlpt.us/using-typescript/03-ts-manage-state.html">
3. 타입스크립트로 리액트 상태 관리하기
</a>
</li>
<li class="chapter " data-level="1.9.4" data-path="../using-typescript/04-ts-context.html">
<a href="https://react.vlpt.us/using-typescript/04-ts-context.html">
4. TypeScript 와 Context API 활용하기
</a>
</li>
<li class="chapter " data-level="1.9.5" data-path="../using-typescript/05-ts-redux.html">
<a href="https://react.vlpt.us/using-typescript/05-ts-redux.html">
5. TypeScript 에서 리덕스 프로처럼 사용하기
</a>
</li>
<li class="chapter " data-level="1.9.6" data-path="../using-typescript/06-ts-redux-middleware.html">
<a href="https://react.vlpt.us/using-typescript/06-ts-redux-middleware.html">
6.타입스크립트에서 리덕스 미들웨어 사용하기 (redux-thunk, redux-saga)
</a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a href="https://www.gitbook.com/" target="blank" class="gitbook-link" style="display: none;">
Published with GitBook
</a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<a class="btn pull-left js-toolbar-action" aria-label="" href="https://react.vlpt.us/basic/23-immer.html#"><i class="fa fa-align-justify"></i></a><a class="btn pull-right js-toolbar-action" aria-label="GitHub" href="https://react.vlpt.us/basic/23-immer.html#"><i class="fa fa-github"></i></a><div class="dropdown pull-right js-toolbar-action"><a class="btn toggle-dropdown" aria-label="Share" href="https://react.vlpt.us/basic/23-immer.html#"><i class="fa fa-share-alt"></i></a><div class="dropdown-menu dropdown-left"><div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div><div class="buttons"><button class="button size-5 ">Facebook</button><button class="button size-5 ">Google+</button><button class="button size-5 ">Twitter</button><button class="button size-5 ">Weibo</button><button class="button size-5 ">Instapaper</button></div></div></div><a class="btn pull-right js-toolbar-action" aria-label="" href="https://react.vlpt.us/basic/23-immer.html#"><i class="fa fa-facebook"></i></a><a class="btn pull-right js-toolbar-action" aria-label="" href="https://react.vlpt.us/basic/23-immer.html#"><i class="fa fa-twitter"></i></a><h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="https://react.vlpt.us/">23. Immer 를 사용한 더 쉬운 불변성 관리</a>
</h1>
</div>
<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<h2 id="23-immer-를-사용한-더-쉬운-불변성-관리">23. Immer 를 사용한 더 쉬운 불변성 관리</h2>
<p>리액트에서 배열이나 객체를 업데이트 해야 할 때에는 직접 수정 하면 안되고 불변성을 지켜주면서 업데이트를 해주어야 합니다.</p>
<p>예를 들자면 다음과 같이 하면 안되고</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> object = {
  a: <span class="hljs-number">1</span>,
  b: <span class="hljs-number">2</span>
};

object.b = <span class="hljs-number">3</span>;
</code></pre>
<p>다음과 같이 ... 연산자를 사용해서 새로운 객체를 만들어주어야 하죠.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> object = {
  a: <span class="hljs-number">1</span>,
  b: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">const</span> nextObject = {
  ...object,
  b: <span class="hljs-number">3</span>
};
</code></pre>
<p>배열도 마찬가지로, <code>push</code>, <code>splice</code> 등의 함수를 사용하거나 n 번째 항목을 직접 수정하면 안되고 다음과 같이 <code>concat</code>, <code>filter</code>, <code>map</code> 등의 함수를 사용해야 합니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> todos = [
  {
    id: <span class="hljs-number">1</span>,
    text: <span class="hljs-string">'할 일 #1'</span>,
    done: <span class="hljs-literal">true</span>
  },
  {
    id: <span class="hljs-number">2</span>
    text: <span class="hljs-string">'할 일 #2'</span>,
    done: <span class="hljs-literal">false</span>
  }
];

<span class="hljs-keyword">const</span> inserted = todos.concat({
  id: <span class="hljs-number">3</span>,
  text: <span class="hljs-string">'할 일 #3'</span>,
  done: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">const</span> filtered = todos.filter(todo =&gt; todo.id !== <span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> toggled = todos.map(
  todo =&gt; todo.id === <span class="hljs-number">2</span>
    ? {
      ...todo,
      done: !todo.done,
    }
    : todo
);
</code></pre>
<p>대부분의 경우 ... 연산자 또는 배열 내장함수를 사용하는건 그렇게 어렵지는 않지만 데이터의 구조가 조금 까다로워지면 불변성을 지켜가면서 새로운 데이터를 생성해내는 코드가 조금 복잡해집니다.</p>
<p>가령 다음과 같은 객체가 있다고 가정해봅시다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> state = {
  posts: [
    {
      id: <span class="hljs-number">1</span>,
      title: <span class="hljs-string">'제목입니다.'</span>,
      body: <span class="hljs-string">'내용입니다.'</span>,
      comments: [
        {
          id: <span class="hljs-number">1</span>,
          text: <span class="hljs-string">'와 정말 잘 읽었습니다.'</span>
        }
      ]
    },
    {
      id: <span class="hljs-number">2</span>,
      title: <span class="hljs-string">'제목입니다.'</span>,
      body: <span class="hljs-string">'내용입니다.'</span>,
      comments: [
        {
          id: <span class="hljs-number">2</span>,
          text: <span class="hljs-string">'또 다른 댓글 어쩌고 저쩌고'</span>
        }
      ]
    }
  ],
  selectedId: <span class="hljs-number">1</span>
};
</code></pre>
<p>여기서 <code>posts</code> 배열 안의 id 가 1 인 <code>post</code> 객체를 찾아서, <code>comments</code> 에 새로운 댓글 객체를 추가해줘야 한다고 가정해봅시다. 그렇다면, 다음과 같이 업데이트 해줘야 할 것입니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> nextState = {
  ...state,
  posts: state.posts.map(post =&gt;
    post.id === <span class="hljs-number">1</span>
      ? {
          ...post,
          comments: post.comments.concat({
            id: <span class="hljs-number">3</span>,
            text: <span class="hljs-string">'새로운 댓글'</span>
          })
        }
      : post
  )
};
</code></pre>
<p>이게 어려운건 아닌데, 솔직히 코드의 구조가 좀 복잡해져서 코드를 봤을 때 한 눈에 들어오질 않습니다.</p>
<p>이럴 때, immer 라는 라이브러리를 사용하면 다음과 같이 구현을 할 수 있답니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> nextState = produce(state, draft =&gt; {
  <span class="hljs-keyword">const</span> post = draft.posts.find(post =&gt; post.id === <span class="hljs-number">1</span>);
  post.comments.push({
    id: <span class="hljs-number">3</span>,
    text: <span class="hljs-string">'와 정말 쉽다!'</span>
  });
});
</code></pre>
<p>어떤가요? 코드가 훨씬 깔끔하고 잘 읽혀지죠?</p>
<p>Immer 를 배우기전에 간단하게 요약을 해드리겠습니다. Immer 를 사용하면 우리가 상태를 업데이트 할 때, 불변성을 신경쓰지 않으면서 업데이트를 해주면 Immer 가 불변성 관리를 대신 해줍니다.</p>
<h3 id="immer-사용법">Immer 사용법</h3>
<p>이번 섹션에서는 우리가 기존에 만들었던 사용자 관리 프로젝트에 Immer 를 적용해보면서 Immer 의 사용법을 알아보겠습니다.</p>
<p>우선 프로젝트에서 다음 명령어를 실행하여 Immer 를 설치해주세요.</p>
<pre><code class="lang-bash">$ yarn add immer
</code></pre>
<p>이 라이브러리를 사용 할 땐 다음과 같이 사용합니다.</p>
<p>우선 코드의 상단에서 immer 를 불러와주어야 합니다. 보통 <code>produce</code> 라는 이름으로 불러옵니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">'immer'</span>;
</code></pre>
<p>그리고 <code>produce</code> 함수를 사용 할 때에는 첫번째 파라미터에는 수정하고 싶은 상태, 두번째 파라미터에는 어떻게 업데이트하고 싶을지 정의하는 함수를 넣어줍니다.</p>
<p>두번째 파라미터에 넣는 함수에서는 불변성에 대해서 신경쓰지 않고 그냥 업데이트 해주면 다 알아서 해줍니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> state = {
  number: <span class="hljs-number">1</span>,
  dontChangeMe: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">const</span> nextState = produce(state, draft =&gt; {
  draft.number += <span class="hljs-number">1</span>;
});

<span class="hljs-built_in">console</span>.log(nextState);
<span class="hljs-comment">// { number: 2, dontChangeMe: 2 }</span>
</code></pre>
<p>다음 링크를 열어서 CodeSandbox 를 열으시면, Immer 를 쉽게 연습해보실 수 있습니다.
<a href="https://codesandbox.io/s/pedantic-grass-ojocz?fontsize=14" target="_blank"><img src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/play-codesandbox.svg" alt="Edit pedantic-grass-ojocz"></a></p>
<p>연습 해보고 싶으시면 위 CodeSandbox 에서 해보시고, 우리 프로젝트에서 사용해보겠습니다.</p>
<h3 id="리듀서에서-immer-사용하기">리듀서에서 Immer 사용하기</h3>
<p>미리 말씀을 드리자면, Immer 를 사용해서 간단해지는 업데이트가 있고, 오히려 코드가 길어지는 업데이트 들이 있습니다.</p>
<p>예를들어서 우리가 만들었던 프로젝트의 상태의 경우 <code>users</code> 배열이 객체의 깊은곳에 위치하지 않기 때문에 새 항목을 추가하거나 제거 할 때는 Immer 를 사용하는 것 보다 <code>concat</code> 과 <code>filter</code> 를 사용하는것이 더 코드가 짧고 편합니다.</p>
<p>하지만, 사용법을 잘 배워보기 위하여 해당 업데이트도 이번 강좌에서 Immer 를 사용하여 처리를 해주겠습니다.</p>
<h4 id="appjs">App.js</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> React, { useReducer, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> UserList <span class="hljs-keyword">from</span> <span class="hljs-string">'./UserList'</span>;
<span class="hljs-keyword">import</span> CreateUser <span class="hljs-keyword">from</span> <span class="hljs-string">'./CreateUser'</span>;
<span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">'immer'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countActiveUsers</span>(<span class="hljs-params">users</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'활성 사용자 수를 세는중...'</span>);
  <span class="hljs-keyword">return</span> users.filter(user =&gt; user.active).length;
}

<span class="hljs-keyword">const</span> initialState = {
  users: [
    {
      id: <span class="hljs-number">1</span>,
      username: <span class="hljs-string">'velopert'</span>,
      email: <span class="hljs-string">'public.velopert@gmail.com'</span>,
      active: <span class="hljs-literal">true</span>
    },
    {
      id: <span class="hljs-number">2</span>,
      username: <span class="hljs-string">'tester'</span>,
      email: <span class="hljs-string">'tester@example.com'</span>,
      active: <span class="hljs-literal">false</span>
    },
    {
      id: <span class="hljs-number">3</span>,
      username: <span class="hljs-string">'liz'</span>,
      email: <span class="hljs-string">'liz@example.com'</span>,
      active: <span class="hljs-literal">false</span>
    }
  ]
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CREATE_USER'</span>:
      <span class="hljs-keyword">return</span> produce(state, draft =&gt; {
        draft.users.push(action.user);
      });
    <span class="hljs-keyword">case</span> <span class="hljs-string">'TOGGLE_USER'</span>:
      <span class="hljs-keyword">return</span> produce(state, draft =&gt; {
        <span class="hljs-keyword">const</span> user = draft.users.find(user =&gt; user.id === action.id);
        user.active = !user.active;
      });
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REMOVE_USER'</span>:
      <span class="hljs-keyword">return</span> produce(state, draft =&gt; {
        <span class="hljs-keyword">const</span> index = draft.users.findIndex(user =&gt; user.id === action.id);
        draft.users.splice(index, <span class="hljs-number">1</span>);
      });
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-comment">// UserDispatch 라는 이름으로 내보내줍니다.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> UserDispatch = React.createContext(<span class="hljs-literal">null</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);

  <span class="hljs-keyword">const</span> { users } = state;

  <span class="hljs-keyword">const</span> count = useMemo(() =&gt; countActiveUsers(users), [users]);
  <span class="hljs-keyword">return</span> (
    &lt;UserDispatch.Provider value={dispatch}&gt;
      &lt;CreateUser /&gt;
      &lt;UserList users={users} /&gt;
      &lt;div&gt;활성사용자 수 : {count}&lt;/div&gt;
    &lt;/UserDispatch.Provider&gt;
  );
}

export default App;
</code></pre>
<p><a href="https://codesandbox.io/s/begin-react-1lzz8?fontsize=14" target="_blank"><img src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/play-codesandbox.svg" alt="Edit begin-react"></a></p>
<p><code>TOGGLE_USER</code> 액션의 경우엔 확실히 Immer 를 사용하니 코드가 깔끔해졌지만 나머지의 경우에는 오히려 코드가 좀 복잡해졌지요? 상황에 따라 잘 선택하여 사용하시면 됩니다. Immer 를 사용한다고 해서 모든 업데이트 로직에서 사용을 하실 필요는 없습니다.</p>
<h3 id="immer-와-함수형-업데이트">Immer 와 함수형 업데이트</h3>
<p>우리가 이전에 <code>useState</code> 를 사용 할 때 함수형 업데이트란걸 할 수 있다고 배웠습니다. 예를 들자면,</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> [todo, setTodo] = useState({
  text: <span class="hljs-string">'Hello'</span>,
  done: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">const</span> onClick = useCallback(() =&gt; {
  setTodo(todo =&gt; ({
    ...todo,
    done: !todo.done
  }));
}, []);
</code></pre>
<p>이렇게 <code>setTodo</code> 함수에 업데이트를 해주는 함수를 넣음으로써, 만약 <code>useCallback</code> 을 사용하는 경우 두번째 파라미터인 <code>deps</code> 배열에 <code>todo</code> 를 넣지 않아도 되게 되지요.</p>
<p>이렇게 함수형 업데이트를 하는 경우에, Immer 를 사용하면 상황에 따라 더 편하게 코드를 작성 할 수 있습니다.</p>
<p>만약에 <code>produce</code> 함수에 두개의 파라미터를 넣게 된다면, 첫번째 파라미터에 넣은 상태를 불변성을 유지하면서 새로운 상태를 만들어주지만,
만약에 첫번째 파라미터를 생략하고 바로 업데이트 함수를 넣어주게 된다면, 반환 값은 새로운 상태가 아닌 상태를 업데이트 해주는 함수가 됩니다. 설명으로 이해하기가 조금 어려울 수 있는데 코드를 보면 조금 더 이해가 쉬워집니다.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> todo = {
  text: <span class="hljs-string">'Hello'</span>,
  done: <span class="hljs-literal">false</span>
};

<span class="hljs-keyword">const</span> updater = produce(draft =&gt; {
  draft.done = !draft.done;
});

<span class="hljs-keyword">const</span> nextTodo = updater(todo);

<span class="hljs-built_in">console</span>.log(nextTodo);
<span class="hljs-comment">// { text: 'Hello', done: true }</span>
</code></pre>
<p>결국 <code>produce</code> 가 반환하는것이 업데이트 함수가 되기 때문에 <code>useState</code> 의 업데이트 함수를 사용 할 떄 다음과 같이 구현 할 수 있게 되지요.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> [todo, setTodo] = useState({
  text: <span class="hljs-string">'Hello'</span>,
  done: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">const</span> onClick = useCallback(() =&gt; {
  setTodo(
    produce(draft =&gt; {
      draft.done = !draft.done;
    })
  );
}, []);
</code></pre>
<p>이러한 속성을 잘 알아두시고, 나중에 필요할때 잘 사용하시면 되겠습니다.</p>
<p>Immer 은 분명히 정말 편한 라이브러리인것은 사실입니다. 하지만, 확실히 알아둘 점은, 성능적으로는 Immer 를 사용하지 않은 코드가 조금 더 빠르다는 점 입니다.</p>
<p><img src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/performance.png" alt=""></p>
<p>위 성능 분석표는 50,000개의 원소중에서 5,000 개의 원소를 업데이트 하는 코드를 비교 했을때의 결과입니다. 보시면, Immer 의 경우 31ms 걸리는 작업이 (map 을 사용하는) Native Reducer 에서는 6ms 걸린 것을 확인 할 수 있습니다.</p>
<p>그런데, 이렇게 데이터가 많은데도 31ms 가 걸린다는 것은 사실 큰 문제가 아닙니다. 인간이 시각적으로 인지 할 수있는 최소 딜레이는 13ms 라고 합니다 (<a href="https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/" target="_blank">참고</a>]) 그런 것을 생각하면 25ms 의 차이는, 사실 그렇게 큰 차이가 아니기 때문에 걱정할 필요 없습니다. 심지어, 데이터가 50,000개 가량 있는게 아니라면 별로 성능 차이가 별로 없을 것이기 때문에 더더욱 걱정하지 않아도 됩니다.</p>
<p>단, Immer 는 JavaScript 엔진의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank">Proxy</a> 라는 기능을 사용하는데, 구형 브라우저 및 react-native 같은 환경에서는 지원되지 않으므로 (Proxy 처럼 작동하지만 Proxy는 아닌) ES5 fallback 을 사용하게 됩니다. ES5 fallback 을 사용하게 되는경우는 191ms 정도로, 꽤나 느려지게 됩니다. 물론, 여전히 데이터가 별로 없다면 크게 걱정 할 필요는 없습니다.</p>
<p>Immer 라이브러리는 확실히 편하기 때문에, 데이터의 구조가 복잡해져서 불변성을 유지하면서 업데이트하려면 코드가 복잡해지는 상황이 온다면, 이를 사용하는 것을 권장드립니다.</p>
<p>다만, 무조건 사용을 하진 마시고, 가능하면 데이터의 구조가 복잡해지게 되는 것을 방지하세요. 그리고 어쩔 수 없을 때 Immer 를 사용하는것이 좋습니다. Immer 를 사용한다고 해도, 필요한곳에만 쓰고, 간단히 처리 될 수 있는 곳에서는 그냥 일반 JavaScript 로 구현하시길 바랍니다.</p>
<script>
      function attachComments() {
        const el = document.querySelector('.markdown-section');
        if (!el) return;
        const script = document.createElement('script');
        script.src = 'https://utteranc.es/client.js';
        script.setAttribute('repo', 'velopert/react-tutorial');
        script.setAttribute('issue-term', 'title');
        script.setAttribute('crossorigin', 'anonymous');
        script.setAttribute('label', 'comments');
        el.appendChild(script);
      }
      setTimeout(attachComments, 100);
    </script>
<div class="utterances">
    <iframe class="utterances-frame" title="Comments" scrolling="no" src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/utterances.html" loading="lazy"></iframe>
  </div></section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a href="https://react.vlpt.us/basic/22-context-dispatch.html" class="navigation navigation-prev " aria-label="Previous page: 22. Context API 를 사용한 전역 값 관리">
<i class="fa fa-angle-left"></i>
</a>
<a href="https://react.vlpt.us/basic/24-class-component.html" class="navigation navigation-next " aria-label="Next page: 24. 클래스형 컴포넌트" style="margin-right: 16px;">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"23. Immer 를 사용한 더 쉬운 불변성 관리","level":"1.2.23","depth":2,"next":{"title":"24. 클래스형 컴포넌트","level":"1.2.24","depth":2,"path":"basic/24-class-component.md","ref":"./basic/24-class-component.md","articles":[]},"previous":{"title":"22. Context API 를 사용한 전역 값 관리","level":"1.2.22","depth":2,"path":"basic/22-context-dispatch.md","ref":"./basic/22-context-dispatch.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["collapsible-chapters","comment","hide-published-with","github","edit-link"],"pluginsConfig":{"github":{"url":"https://github.com/velopert/react-tutorial"},"search":{},"collapsible-chapters":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"hide-published-with":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"edit-link":{"label":"수정 요청하기","base":"https://github.com/velopert/react-tutorial/edit/master"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"comment":{}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"basic/23-immer.md","mtime":"2019-06-30T07:02:10.280Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-25T13:34:28.960Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/gitbook.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/theme.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/collapsible-chapters.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/plugin.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/plugin.js(1).다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/plugin.js(2).다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/search-engine.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/search.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/lunr.min.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/search-lunr.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/buttons.js.다운로드"></script>
<script src="./23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook_files/fontsettings.js.다운로드"></script>


</body></html>