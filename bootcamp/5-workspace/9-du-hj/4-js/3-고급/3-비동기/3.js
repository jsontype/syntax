/*
    [비동기, 동기]

    1. JavaScript는 동기식 언어이다.
        자바스크립트는 한 번에 하나의 작업을 수행한다.        
        이러한 동작을 단일 스레드(싱글 스레드), 동기(Synchronous)라고 부른다.
        그러나 JavaScript에서도 힙, 스택, 큐를 이용해 비동기 처리가 가능하다.

    1. 동기
        한 작업이 실행되는 동안 다른 작업은 멈춰 기다리고, "실행된 순서"대로 실행한다.
        JS에서는 Heap에서 변수, 함수등의 값을 담고, "실행된 순서"대로 Que에 올린 다음 Stack이 비었을 때 올려서 한줄씩 실행한다.
        작업이 끝날 때까지 기다리는 동안 중지 상태가 되기 때문에 다른 작업을 할 수 없다.

    1. 비동기
        한 작업이 실행되는 동안 다른 작업도 실행되고, "먼저 로딩된 순서"대로 실행한다.
        JS에서는 Heap에서 변수, 함수등의 값을 담고, "먼저 로딩된 순서"대로 Que에 올린 다음 Stack이 비었을 때 올려서 한줄씩 실행한다.
        작업의 흐름이 멈추지 않기 때문에 동시에 여러 가지 작업을 처리할 수도 있고, 기다리는 과정에서 다른 함수를 호출할 수도 있다.

        다음과 같이 처리 시간이 오래 걸리는 작업들은(1초 이상) 주로 비동기적으로 처리하게 된다.
            1. Ajax Web API 요청: 서버 쪽에서 데이터를 받아오는 상황 (fetch, axios등을 사용)
            2. 파일읽기 : 암호화/복호화를 하여 파일을 읽어오는 상황.  (io를 사용)
            3. 작업예약 : 작업을 몇초 후에 스케쥴링 해야 하는 상황. (setTimeout을 사용)
            
        * 테스트시, 아래 fetch 비동기 로직은 브라우저에서 열어서 실행해야하므로 주의!
*/

// 1. 비동기 (fetch를 사용) : 분명 동기보다 먼저 실행되지만 로딩 시간 동안 Que에 올라가므로 아래 동기처리보다 나중에 실행된다.
function getMovie(url) {
  fetch(url)
    .then((res) => {
      return res.json();
    })
    .then((json) => {
      console.log("비동기 fetch 작업 완료: ", json.data.movies);
    });
}
getMovie("https://yts.mx/api/v2/list_movies.json");

// 1. 비동기 (setTimeout을 사용) : 분명 동기보다 먼저 실행되지만 로딩 시간 동안 Que에 올라가므로 아래 동기처리보다 나중에 실행된다.
function work() {
  setTimeout(() => {
    const start = Date.now();
    for (let i = 0; i < 1000000000; i++) {}
    const end = Date.now();
    console.log("비동기 setTimeout 작업 완료: ", end - start + "ms");
  }, 1000); // setTimeout에서 딜레이를 줄 시간을 정한다. 1000ms -> 1초
}
work();

// 1. 동기 : heap에 들어간 뒤 (대기실과 que를 거치지 않고) 바로 stack으로 올라간다.
console.log("동기 작업 완료");

/*
  1. 테스트
      이번에는 브라우저를 열어서 html 파일을 확인해보자.
      그 후 콘솔로그를 열어보자.
      동기 처리가 뒤에 있어도 stack에 먼저 올라가므로 먼저 처리되고, 비동기처리가 뒤에 나오는 것을 볼 수 있다.
*/
