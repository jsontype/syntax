/*
  [객체에 Spreading을 쓰기 + 추가, 수정, 삭제 방법]
*/

// 1. 리액트에서 "객체, 배열"을 수정할 때, "불변성의 법칙"을 지켜야하는 이유
// 리액트는 컴포넌트 여러개를 쓴다.
// -> 한 컴포넌트에서 객체 하나를 설정하면, 모든 컴포넌트가 다 그 곳을 참조한다.
// -> 그러나 실제로 객체가 변경되어도, 얘를 감지할 수 없다. 왜냐면, 주소이기 때문에 변화를 감지하기 불가능하기 때문이다.
// -> 변화를 감지해야 퍼포먼스튜닝이 가능하다. 안 그러면 deps도 안되고... useEffect 등등 다 못쓴다...
// -> 그 바뀐 컴포넌트 부분을 캐치해서 거기만 재렌더링 해줘야하기 때문에, 리액트는 다음과 같은 방법으로 배열이나 객체를 수정한다.
// -> 새로운 객체주소를 만들고, 거기다 기존의 객체의 값을 넣고, 변경된 부분만 바꿔 넣고, 기존 객체를 그 "주소"으로 갈아끼운다. 그 뒤, 기존의 주소를 삭제한다.
// -> 이로써 리액트에는 변화감지가 가능해진다. 그래서 바뀐 객체를 읽어서 해당 객체를 사용하고 있는 컴포넌트의 퍼포먼스튜닝이 가능해진다.



// 1. 사전지식의 준비 : 배열객체 초급복사
// 값 참조일 때는 다음처럼 해도 서로 다른 메모리 주소를 할당한다.
const a = 1
const b = a 
// 주소 참조일 때는 다르다.
const user1 = { id: "yang", pw: "1234" }
const user1New1 = user1 // 동일 주소가 되어버린다. user1값을 바꾸면 user1New도 바뀌므로 복사라 할 수 없다.
const user1New2 = JSON.parse(JSON.stringify(user1)) // 이럴 때 해결 방법은 JSON 파싱을 하거나, 아래처럼 spreading 을 사용한다.



// 1. 불변성을 깨지 않고 객체 추가, 수정, 삭제하기
const user = { id: "yang", pw: "1234" }
// 이렇게 바꾸는 방식은 불변성을 깨뜨리므로 리액트에서는 쓰지 않는다.
user.pw = "2345" 
// 리액트는 아래처럼 새 주소를 만든뒤 기존 주소를 삭제하고 갈아끼우는 방식으로 불변성을 지킨다.
const user1New = { ...user, pw: "3333"} // 객체 변경
const user1Add = { ...user, name: "Hwang" } // 객체 추가
const { pw, ...userDelete } = user // 객체 삭제



// 1. 불변성을 깨지 않고 배열 추가, 수정, 삭제하기
const todos = [{ id: 1, text: '할 일 #1', done: true}]
// 이렇게 바꾸는 방식은 불변성을 깨뜨리므로 리액트에서는 쓰지 않는다.
todos.push({ id: 2, text: '할 일 #2', done: false})
// 리액트는 아래처럼 새 주소를 만든뒤 기존 주소를 삭제하고 갈아끼우는 방식으로 불변성을 지킨다.
const todosAdd = [ ...todos, { id: 3, text: '할일', done: false } ] // 배열 추가
const todosDelete = todos.filter((item) => { return item.id !== 2 }) // 배열 삭제 : id = 2인 것을 삭제
const todosChange = todos.map((item) => { return (item.id === 2) ? { ...item, done: true } : item }) // 배열 변경 : id = 2번의 done을 토글링
