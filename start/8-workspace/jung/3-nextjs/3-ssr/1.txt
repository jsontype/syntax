1. app/movie 폴더를 카피해 movie-csr로 변경. movie/ → movie-csr/ 로 링크처 변경

1. app/movie 폴더를 카피해 movie-ssr를 생성 후, SSR 페이지로 변경하기

1. movie-ssr이, 기존의 movie-csr(use client 사용)과 뭐가 다른지 코드 비교하기
  - 서버 컴포넌트 (SSR)
    파일 최상단에 'use client' ❌
    렌더링 위치: 서버에서 렌더링 후 HTML을 클라이언트에 전송
    데이터 패칭: 서버에서 직접 가져옴 (fetch 가능)
    초기 로딩 속도: 빠름 (서버에서 데이터를 가져오므로 초기 로딩 속도가 빠름. 완전한 HTML가 처음부터 제공되므로 클라이언트에서 실행할 JS가 줄어듦 → 성능 최적화)
      - SSR 미리 준비를 하고 대기하고 있다가 나오는 여자친구 vs CSR 부르면 그때부터 머리감고 화장하고 준비하는 여자친구
      - SSR
        웹사이트를 로딩할 때, 클라이언트가 서버에게 "이 페이지의 HTML을 주세요!" 라고 요청함.
        이때 서버는 데이터를 가져와서, 완성된 HTML을 만들어서 클라이언트에 보냄.
        브라우져는 그래서 기다릴 필요없이 처음부터 완성된 페이지를 받고 있음.
      - CSR
        사용자가 브라우저에서 페이지를 요청함.
        <html>
          <body>
            <div id="app"> <!-- 화면이 비어 있음 --> </div>
            <script src="app.js"></script> <!-- 자바스크립트 실행 -->
          </body>
        </html>
        이때, 브라우저는 빈 화면을 받고, 자바스크립트를 실행해서 화면을 그림. 이때 서버에서 데이터를 보내주는데 시간이 걸릴 수 있음.
        브라우져는 그 데이터를 받아서 화면을 업데이트함. 그래서 사용자는 화면이 늦게 나타나는 것을 볼 수 있음.
      - 예상되는 질문
        Q. 어차피 서버도 async로 api에서 로딩을 받아오잖아?
        A. 서버와 클라이언트의 "기다리는 위치" 차이
          클라이언트 컴포넌트 (useEffect 사용): 브라우저가 HTML을 받은 후, API 응답이 올 때까지 "빈 화면"
          서버 컴포넌트 (fetch 사용): 서버에서 HTML을 생성하기 전에, API 응답만 기다린 후, 준비시켜둔 "완성된 화면"
          물론 서버 컴포넌트도 열렸을 때 fetch()를 호출하는 건 동일하지만, 이건 사용자가 페이지를 요청한 순간 실행됨. (클라이언트는 API를 페이지 요청 순간 바로 실행하지 않음. HTML이 먼저 실행됨.)
          이제 서버는 API 응답을 받을 때까지 기다렸다가 HTML을 만들어서 사용자에게 보내줌.
          그래서 사용자는 빈 화면을 보지 않고, 바로 완성된 페이지를 받을 수 있음.
          👉 브라우저는 아직 HTML을 받지 못하고 있음. 하지만 이 과정이 사용자가 직접 기다리는 게 아니라, 서버가 기다리는 거라 "체감 속도"가 빠름. 실제 속도도 API가 HTML 렌더링을 기다리지 않고 먼저 호출되므로 더 빠름.
    생산성:
      사실 코딩하기 불편하긴 함.
      서버에서 데이터를 한번에 다 가져와서 렌더링하는 페이지에 정적인 페이지에 적합. (Movie 앱, EC 사이트, 부동산 사이트 등)
      동적인 페이지는 CSR 방식이 더 적합. (Counter 앱, B2B 작업앱 등)
    JS 번들 크기 작음: (클라이언트로 불필요한 JS 전달 X)
    상태 관리: useState, useEffect를 쓰지 않고 데이터를 포함해야 함
    인터랙티브 UI(이벤트 핸들링): ❌ 불가능 (onClick 같은 이벤트 처리 X)
    SEO 최적화:	✅ 우수 (서버에서 완전한 HTML 제공하고 있으므로, 검색 엔진이 크롤링할 때 전체 HTML을 읽을 수 있음)

  - 클라이언트 컴포넌트 (CSR)
    파일 최상단에 'use client' 필요
    렌더링 위치: 브라우저에서 실행됨 (JavaScript 필요)
    데이터 패칭: useEffect를 사용하여 클라이언트에서 데이터 가져옴
    초기 로딩 속도: 느림 (초기 화면 렌더링 후 데이터 가져옴. useEffect를 사용하여 클라이언트에서 데이터 요청을 보내야 함)
    생산성: 동적으로 데이터를 갱신하는 UI를 만들기 좋음.
    JS 번들 크기 작음: 큼 (모든 코드가 클라이언트로 전송됨)
    상태 관리: useState, useEffect로 상태 관리해야 함
    인터랙티브 UI(이벤트 핸들링): ✅ 가능 (onClick, useState 등 가능)
    SEO 최적화:	❌ 부족 (CSR 방식이므로 초기 HTML이 비어 있음. useEffect로 데이터를 가져오기 때문에 첫 화면이 렌더링된 후 데이터를 로드 → 느려질 수 있음)

  - 결론
    * 혼합해서 사용 가능 → 대부분 서버 컴포넌트에서 기본적인 데이터 로딩을 처리 → 클라이언트 컴포넌트에서 인터랙티브한 요소를 추가하는 방식이 이상적.
    * 추천구조: 서버 컴포넌트에서 데이터 패칭 → 클라이언트 컴포넌트에서 UI 인터랙션 처리    
      ```
        <ServerFetchedData />
        <ClientInteractiveComponent />
      ```
    즉, "서버에서 데이터 가져오기 + 클라이언트에서 인터랙티브 UI 관리"가 최적의 패턴!
