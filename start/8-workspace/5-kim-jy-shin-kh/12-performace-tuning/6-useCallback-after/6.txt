[퍼포먼스튜닝 - useCallback으로 함수 최적화하기 - 후]

1. useCallback을 사용하는 이유
  보다 구체적으로 말하면, memo로 메모화 하더라도 컴포넌트에 "함수"를 사용하고 있다면 재랜더링이 되는데,
    이를 useCallback로 메모화시켜 Props로 전달하여 구성 요소의 불필요한 재 렌더링을 건너뛸 수 있다.
  useCallback은 Deps 배열에는 콜백함수가 사용하는 변수들을 담아줘야 한다.
    예시1) const result = useCallback(() => console.log("doSomething"), []);
    예시2) const result = useCallback(() => console.log(count), [count])



1. src/App.js
  import React, { useState, memo, useCallback } from "react";

  const Child = memo((props) => {
    let i = 0;
    while (i < 3000000000) i++;
    console.log("render Child");
    return <button onClick={props.onClick}>Child: {props.count}</button>;
  });

  function App() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);

    // ★★ 함수 메모화
    // 아래처럼 함수를 유즈콜백으로 메모화시킨다.
    // 그러면, 신, 구 onClick이 동일한 값을 가지는 한, Child 컴포넌트는 재렌더링되지 않는다.
    // 정리하자면,
    // useCallback은 컴포넌트 재렌더링을 memo로 하는 동안에 함수를 props로 넘겨주는 경우에,
    // useMemo는 컴포넌트 재렌더링을 memo로 하는 동안에 값을 props로 넘겨주는 경우, 함께 곁들여 사용한다.
    const onClick = useCallback(() => {
      setCount2(count2 + 1);
    }, [count2]);

    return (
      <>
        <button onClick={() => setCount1(count1 + 1)}>App: {count1}</button>
        <Child onClick={onClick} count={count2} />
      </>
    );
  }

  export default App;



1. 테스트 : Child를 눌렀을 때, 다른 곳이 재렌더링 되지 않음을 확인
  $ cd app1
  $ npm start



1. useCallback의 주의점
  useCallback는 memo와 병용하는 것이므로, 
  useCallback을 쓰더라도 다음과 같이 쓴다면 컴퍼넌트의 불필요한 재렌더링을 막을 수 없으므로 주의.
  - memo 메모화하지 않은 구성 요소에 useCallback 메모화 된 콜백 함수 전달 : 
      const Child에 memo가 없으면 useCallback을 쓰더라도 Child 컴포넌트는 항상 재렌더링 된다.
  - useCallback로 메모화한 콜백 함수를, 그것을 생성한 컴퍼넌트 스스로 이용 : 
      Child가 컴포넌트화 되어있지 않고 App 컴포넌트의 리턴 안에 
      <button onClick={handleClick}>logging</button>의 형태로 들어가있으면, 
      useCallback을 쓰더라도 해당 button 태그는 항상 재렌더링 된다.
