[SSR 최적화: getServerSideProps에서 캐싱 기능을 사용해, 데이터 호출 시도를 줄이기]

1. 사전준비: 프로젝트를 새로 깔지 않고, 이전 챕터에서의 app2-after 코드를 그대로 카피해서 가지고 온다.
  똑같이 두번 가져와서,
  app1-before 폴더는 그대로 두고,
  app2-after 폴더는 아래대로 수정한다.
  * 복붙시 자동 임포트로 인한 트러블 예방하기
    tsconfig.json 파일을 확인해서, ["../app1-before/src/*"] 등 과거의 파일을 참조하진 않는지 확인한다
    만일 app1-before 것을 참조한다면 현재 tsconfig.json 파일처럼 수정한다.

1. 설치: app2-router에 최적화용 패키지 설치
  $ npm i css-minimizer-webpack-plugin cssnano postcss-preset-env

1. app2-router에서 라이트하우스 성능 점수 확인
  라이트하우스 통지사항(Diagnostics 항목) 중 최적화할 항목들을 확인한다.
  해당 항목들을 하나씩 프롬프트를 날려 확인. 아래는 예시이다.
    "Largest Contentful Paint element 이것만 해결"
    "이미지 랜더링을 더 빠르게 하는 방법이 필요해"
    "TTFB 80% 1,630 ms. 이게 문제야"
    "지금 상황에서 Render Delay 90% 1,690 ms 이거만 줄이면 딱 좋은데"

1. next.config.js 수정: 이미지, API 캐싱 관련 최적화
  - 이미지 관련: 이미지의 생성시 기준이 되는 디바이스 너비를 지정하여 이미지 최적화 설정
  - 이미지 관련: Largest Contentful Paint element - TTFB 해결
    서버에서 받는 속도가 느려 next.config.js 에서 캐시헤더를 추가하여 성능을 향상
  - API 캐싱 관련: 서버 사이드 웹소켓 최적화하여 back/forward 캐시 문제 해결
    
1. src/pages/index.tsx 수정: 이미지, API 캐싱 관련 최적화
  - 이미지 관련: Largest Contentful Paint image was lazily loaded 해결
    바로 화면에 보이는 이미지에 조건부 prioriy, loading을 eager, quality저하를 넣어 성능향상
  - API 캐싱 관련: API 로딩에 try/catch 블록 추가: 자세한건 [ // ! try/catch 블록의 필요성: ] 으로 검색하여 주석확인

1. 테스트
  수정한 각 페이지를 기존의 before 코드와 비교해가며 최적화 처리를 어떻게 했는지 확인

  $ cd app1-before
  $ npm run dev
  $ localhost:3000 에서 테스트

  $ cd app2-after
  $ npm run dev
  $ localhost:3001 에서 테스트

  최적화 확인: 구체적인 최적화 확인 방법은 "1-기본개념/1.txt" 참조
  - Chrome DevTools의 Performance 탭
  - Lighthouse 성능 점수
  - Network 탭의 리소스 로딩 시간
  - React DevTools의 Profiler  
