[Next 15 react-query 페칭]

1. 데이터 페칭 라이브러리
  React의 데이터 페칭에는 다음과 같은 방법들이 있다.
  🔹 useEffect + fetch: 기본 방식.
  🔹 Redux-thunk: 전역 상태관리 방식. 비동기 로직을 액션으로 분리. 대규모 앱에서 사용.
  🔹 Redux-saga: 전역 상태관리 방식. generator 기반 사이드이펙트 처리로 복잡한 흐름을 가지고 있다. polling이 필요할 때 사용.
  🔹 Redux-toolkit(RTK): 전역 상태관리 방식. Redux-thunk를 쉽게 바꾼 것. 리덕스의 모던 개발 표준.
  🔹 Zustand, Jotai, Recoil 등: 가볍고 간단한 상태 공유. 가능한 미니멀하게 전역 상태 관리를 하고자 할 때 사용.
  🔹 React-query: 비동기 + 캐싱 + 자동 리페치. 서버 데이터를 중심으로 하는 앱에서 사용. 
  🔹 SWR: lightweight. React Query Next.js 에서 특히 많이 씀
  🔹 GraphQL Apollo Client     /GraphQL 쿼리 관리 특화 /GraphQL API 사용 시
  🔹 Next.js 서버                        /getServerSideProps, getStaticProps, App Router async /SSR/SSG/ISR 가능 /SEO/빠른 초기 로딩
  🔹 커스텀                                  /Custom Hook (useFetch, useUser)        /페칭로직 재사용 /다수 컴포넌트에서 동일 로직 필요 시

1. 실제 현장에서는 fetch -> axios -> redux-sage, redux-thunk, mobx, .... -> useSWR -> react-query 역사적 흐름 있었음.
  ...에 들어갈 것들
  지금 리액트 쿼리 많이 사용함. 페칭할 때 useQuery, useMutation, useInfiniteQuery, usePaginatedQuery 등등 본적 있다면 그게 이거임. ㅇㅇ
  react-query를 쓰는 이유들을 정리해보자면...
  react-query를 쓰는 이유: 
    - (이번 강에 할 것) 서버 페치 함수에서 자동으로 error, loading, success 결과값을 내어주니, useState 설정 없이 SSR에서 로딩 구현하기가 가능하다.
    - (이번 강에 할 것) useMutation을 사용해서, 쿼리와 뮤테이션을 구분할 수 있다.
    - 쿼리 키 시스템을 제공한다.
    - fresh, stale, inactive 상태 관리 가능하다.
    - 캐싱에 유리함. useQueryClient를 사용해서, 캐싱 등 각종 쿼리 클라이언트를 사용할 수 있다.
    - useInfiniteQuery를 사용해서, 무한 스크롤을 구현할 수 있다.
    - usePaginatedQuery를 사용해서, 페이지네이션을 구현할 수 있다.

1. react-query를 쓰는 이유: SSR에서 로딩 구현하기
  - SortPulldown에서 적용을 누를 때마다 SSR, SSG에서 재패치가 발생해서 로딩이 발생하고 있는데, 기본적으로 SSR은 로딩이 없음을 전제하고 있기에.
    서치파람 마지막에서 로딩이 발생을 하는데 ssr임 이럴때 로딩만을 위해서 셋로딩 이런거할라고 클라이언트사이드로 바꾼다는 말이 안되고, 
    페치말고 리액트 쿼리를 쓰면 일단 로딩 에러 데이타 동시에 서버컴포에서 쓸수있게 제공해주므로 좋음
  - 이때 리액트 쿼리의 useQuery를 사용하면 된다.
    useQuery는 서버에서 데이터를 가져오는 훅이다. useQuery는 세가지 상태를 가지고 있다. loading, error, data 이다.
    useQuery는 서버에서 데이터를 가져오는 동안 loading 상태가 된다. 데이터가 성공적으로 가져와지면 data 상태가 된다. 데이터 가져오기에 실패하면 error 상태가 된다.
    이걸로 SSR, SSG의 suspense(pending, loading) 상태를 구현하면 된다.
  - error, loading, success를 useState로 직접 setState해서 관리하지 않아도 됨 -> csr이여야 했었는데, ssr는 안된다는 얘기? -> 해결
    const { isLoading, error, data } = useQuery('repoData', () =>
      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(res =>
        res.json(),
      ),
    )
  - 과제: SSR에서 로딩 구현하기 (CSR처럼 setLoading을 쓸 수 없으니 react-query의 useQuery를 써서 loading을 구현한다.)
  - 과제: SSR에서 에러 처리하기 (useQuery의 error를 사용해서 에러를 처리한다.)
  - 과제: SSR에서 성공 처리하기 (useQuery의 success를 사용해서 성공을 처리한다.)

1. react-query를 쓰는 이유: useQuery, useMutation을 사용해서, 쿼리와 뮤테이션을 구분할 수 있다.
  useMutation(
    (newTodo) => fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify(newTodo),
    }),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('todos')
      },
    }
  )

1. 테스트: 리액트쿼리로 무비 페칭이 똑같이 잘 되는지 확인
  $ cd app1
  $ npm run dev
  - localhost:3000/movies 무비리스트 페이지에 접속한다.
  - 리액트 쿼리로도 각각의 무비 리스트 페이지가 잘 페칭되고, 표시되는지 확인한다.
    http://localhost:3000/movies
    http://localhost:3000/movies?sort=rating&limit=20
    http://localhost:3000/movies?sort=year&limit=10
    http://localhost:3000/movies?sort=year&limit=30
    http://localhost:3000/movies?sort=year&limit=50

1. 다음 과제: React Query의 다양한 부가 기능 활용하기 (특히 캐싱)
  * 다음 과제: SSR에서 쿼리 키를 사용하기 (useQuery의 queryKey를 사용해서 쿼리 키를 사용한다.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용하기 (useQueryClient를 사용해서 쿼리 클라이언트를 사용한다.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 무효화하기 (useQueryClient의 invalidateQueries를 사용해서 쿼리 무효화하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 리패치하기 (useQueryClient의 refetchQueries를 사용해서 쿼리 리패치하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 리셋하기 (useQueryClient의 resetQueries를 사용해서 쿼리 리셋하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 삭제하기 (useQueryClient의 removeQueries를 사용해서 쿼리 삭제하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 캐시하기 (useQueryClient의 setQueryData를 사용해서 쿼리 캐시하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 캐시 삭제하기 (useQueryClient의 clear로 쿼리 캐시 삭제하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 캐시 무효화하기 (useQueryClient의 invalidateQueries로 쿼리 캐시 무효화하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 캐시 리패치하기 (useQueryClient의 refetchQueries로 쿼리 캐시 리패치하기.)
  * 다음 과제: SSR에서 쿼리 클라이언트를 사용해서 쿼리 캐시 리셋하기 (useQueryClient의 resetQueries로 쿼리 캐시 리셋하기.)
