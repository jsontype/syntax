// 기초학습

// 값 참조 변수 : 값 자체가 바뀔 때마다 변수 자체도 변했다고 할 수 있다.
// 일반 JS에서, primitive type은 값 참조 변수로 사용한다.
let a = 1
let b = 'hello'
a = 2
b = 'world'

// 주소 참조 변수 : 메모리 주소를 참조하므로 값이 변해도 주소는 변하지 않으므로 변수 자체가 변했다고 할 수 없다. 따라서 상수변수로 사용한다. 
// 일반 JS에서, reference type은 주소 참조 변수로 사용한다.
// Vue나 React에서는, 모든 변수들을 주소 참조 변수로 사용한다. (이유는 맨 아래에 적어놨다.)
const c = [1, 2, 3]
const d = { id: 1, name: 'jack' }
const e = [{ id: 1, name: 'jack' }, { id: 2, name: 'rose' }]
c.push(4) // [ 1, 2, 3, 4 ]
c.unshift(0) // [ 0, 1, 2, 3, 4 ]
c.pop() // [ 0, 1, 2, 3 ]
c.splice(2, 2) // [ 0, 1 ]
const length = c.length // 2
console.log(length)
e.push({
  id: 3,
  name: 'john'
})
console.log(e)

// 참고: Vue나 React에서는, 모든 변수들을 주소 참조 변수로 사용하는 이유
// Vue와 React는 값 참조 변수를 사용하지 않는다.
// 이들은 상태 변수(state)을 변경할 때 데이터의 값의 "불변성의 법칙"을 지켜야하기 때문이다.

// * "불변성의 법칙"을 지켜야 하는 이유는 다음과 같다.
// 1. Life Cycle Method를 구현하기 때문에 배열, 객체 State의 변화를 감지해야한다.
// 2. Performance을 할 때에도 배열, 객체 State의 변화를 감지해야한다. (변화 감지 후 바뀐 컴포넌트 부분만 캐치해서 재렌더링해서 최적화하기 때문)

// * 뷰나 리액트는, 아래와 같은 방식으로, 상태 변수(state)라는 객체의 변화감지를 할 수 있게 한다.
// 1. 새로운 객체주소를 만들고 → 거기다 기존의 객체의 값을 넣은 뒤 변경된 부분만 바꿔 넣고 → 기존 객체를 그 "주소"으로 갈아끼운다. → 기존의 주소는 삭제한다.
// 2. 자동으로 주소를 변경하고, 이와 동시에 기존 주소를 바로 삭제하니까 메모리 문제는 없다.        
// 요약하면, 뷰나 리액트는 배열, 객체를 쓸 때, 변화를 감지하기 위해서, 불변성을 지키고 변경시 새 주소로 갈아끼우는 방식을 채용한다.

// * 만일, 값 참조 변수를 사용하면 아래와 같은 문제가 발생할 것이다. (Vue의 경우)
// 1. life cycle hook이 작동하지 않는다.
// 2. computed가 작동하지 않는다.
// 3. watch가 작동하지 않는다.
// 4. v-model이 작동하지 않는다.
// 5. v-if가 작동하지 않는다.
// 6. v-for가 작동하지 않는다.
// 7. v-show가 작동하지 않는다.
// ... 그 외의 무한한 문제가 발생한다.
