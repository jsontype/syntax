composables 쓰는 이유 : UI와 로직 분리

그리고 여기서부터는 각 앱에 적용하는걸 볼건데, 이건 간단해서 한 페이지에 넣어도 되잖냐 생각할 수가 있는데
보다 복잡한 앱을 상정하고 하는거다

리액트보다 어려워보일수있으나 아니다. 리액트가 훨 어렵다.




[Custom Hooks: use...]

... GPT ...


1. 사전준비 : 초급의 counter-app을 가져온다.
기본적인 카운터 앱을 기반으로, 카운트 관련 로직을 별도의 커스텀 훅(composable)으로 분리하고 관리할 수 있는 방법을 보여드리겠습니다. 이렇게 하면 카운터 기능을 다른 컴포넌트에서도 쉽게 재사용할 수 있습니다.

1. useCounter: 카운터 로직 관리
카운터의 증가, 감소 기능과 카운트 상태를 관리하는 커스텀 훅을 만듭니다.

src/composables/useCounter.ts
typescript
Copy code
import { ref } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue);

  function increase() {
    count.value++;
  }

  function decrease() {
    if (count.value > 0) {  // Optionally prevent going below zero
      count.value--;
    }
  }

  return { count, increase, decrease };
}
2. CounterApp.vue: 컴포넌트 수정
useCounter 커스텀 훅을 사용하여 카운터 기능을 간결하게 구현합니다.

vue
Copy code
<template>
  <h1>Counter App</h1>
  <div>
    <h2>카운트: {{ count }}</h2>
    <button @click="increase">+</button>
    <button @click="decrease">-</button>
  </div>
</template>

<script setup lang="ts">
import { useCounter } from '@/composables/useCounter';

const { count, increase, decrease } = useCounter();
</script>

<style scoped>
button {
  margin: 5px;
  padding: 10px 20px;
}
</style>
3. 마무리
위의 예시에서 useCounter 커스텀 훅을 통해 카운터 관련 로직을 모듈화하여 다른 컴포넌트에서도 쉽게 재사용할 수 있습니다. 커스텀 훅을 사용함으로써 카운터 앱의 구성 요소를 더욱 단순화하고, 코드의 유지 관리와 확장성을 향상시킬 수 있습니다.

이 접근 방식은 Vue.js에서 커스텀 훅을 활용하여 컴포넌트 간에 공통 로직을 공유하고, 각 컴포넌트의 코드를 더욱 깔끔하게 유지하는 데 큰 도움이 됩니다.




... 아래는 템플릿임 ...

1. 사전준비 : init 앱을 가지고 온다.

1. 사전준비 : src/components/HelloWorld.vue 삭제

1. 커스텀 훅이란?
  재사용 가능한 로직을 별도의 훅 함수(use~)로 만든 것을 말한다.
  여러 컴포넌트에서 동일한 기능을 사용할 때 유용하다.
  커스텀 훅스를 모아두는 특정한 표준 폴더는 없지만, 일반적으로 "hooks" 또는 "composables" 라는 폴더명을 사용하므로 참고하자.

1. src/composables/useMousePosition.js 생성 : 마우스 위치를 추적하는 커스텀 훅스
  ```
    import { ref, onMounted, onUnmounted } from 'vue';

    export function useMousePosition() {
      const x = ref(0);
      const y = ref(0);

      function update(e) {
        x.value = e.pageX;
        y.value = e.pageY;
      }

      onMounted(() => window.addEventListener('mousemove', update));
      onUnmounted(() => window.removeEventListener('mousemove', update));

      return { x, y };
    }
  ```

1. src/components/MousePosition.vue 생성 : 만든 커스텀 훅스는 아래와 같이 꺼내서 사용한다.
  ```
    <template>
      <div>
        X: {{ x }}, Y: {{ y }}
      </div>
    </template>

    <script setup>
    import { useMousePosition } from '@/composables/useMousePosition';

    const { x, y } = useMousePosition();
    </script>
  ```

1. src/App.vue 수정 : 컴포넌트를 호출한다.
  ```
    <template>
      <MousePosition />
    </template>

    <script setup lang="ts">
    import MousePosition from '@/components/MousePosition.vue'
    </script>

    <style scoped>
    </style>
  ```

1. 테스트
  $ cd app1
  $ npm run dev



[실무에서 쓸만한 커스텀 훅스의 예시]

1. 폼 관련
  useForm: 폼 데이터 관리와 유효성 검사 로직을 캡슐화한다.
  useFieldArray: 배열로 구성된 폼 데이터를 관리한다.
  useReactiveState: 상태 저장 컴포넌트에서 데이터를 선언적으로 관리한다.
  기타
  useDocumentTitle: 컴포넌트의 상태에 따라 브라우저의 문서 제목을 변경한다.

1. UI/UX 및 이벤트 처리
  useDebounce: 빠른 연속 입력에서의 성능 최적화를 위해 Debounce 기능을 제공한다.
  useThrottle: 과도한 이벤트 발생을 제한하기 위해 Throttle 기능을 제공한다.
  useEventListener: 이벤트 리스너를 등록하고 제거하는 로직을 간편화한다.
  useToggle: 버튼 클릭 시 컴포넌트의 상태를 토글한다.
  useIntersectionObserver: 컴포넌트의 화면 노출 여부를 감지한다.

1. 화면 및 위치 추적
  useWindowSize: 브라우저 창 크기의 변경을 감지한다.
  useWindowResize: 브라우저 창의 크기가 변경될 때마다 이벤트를 감지한다.
  useMousePosition: 마우스의 현재 위치를 추적한다.
  useScrollPosition: 스크롤 위치를 추적한다.
  useResizeObserver: 객체의 크기 변경을 감지한다.

1. 스토리지 관련
  useLocalStorage: 로컬 스토리지에 데이터를 저장하고 검색한다.
  useSessionStorage: 세션 스토리지에 데이터를 저장하고 검색한다.

1. API 및 데이터 관련
  useApi: API 요청을 보내고 응답을 처리하며, 응답 상태에 따라 오류 처리를 한다.
  useFetchData: 서버에서 데이터를 가져와 컴포넌트의 상태를 업데이트한다. 비동기 HTTP 요청을 처리하는 로직을 포함한다.  

1. 마무리
  이러한 카테고리화는 각 훅스의 기능과 사용 목적에 따라 이루어졌으며, 실제 프로젝트에서 필요에 따라 다른 방식으로 분류하거나 새로운 카테고리를 추가할 수 있다. 
  커스텀 훅스는 중복을 제거하여, 프로젝트의 구조와 유지보수를 용이하게 하는 데 도움을 준다. 실제 사용할 때는 GPT 등을 참조해서 만들면 된다.
