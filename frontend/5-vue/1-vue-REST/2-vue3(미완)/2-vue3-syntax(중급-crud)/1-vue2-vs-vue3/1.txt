[Vue3 무엇이 바뀌었는가?]
참조 : https://velog.io/@bluestragglr/Vue3-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%B0%94%EB%80%8C%EB%82%98%EC%9A%94

1. 요약
  Composition API라는게 들어오면서 데이터 선언, 함수 선언, 상태 관리 방법이 약간 변했다.
  컴포넌트 내에서 데이터, 함수, 상태를 호출하는 방식도 변했다.

1. 차이점 : 여러개의 루트 엘리먼트 허용
  Vue2의 템플릿은 하나의 루트 엘리먼트만 허용하였다. 
  하지만 Vue3부터는 여러 개의 루트 엘리먼트를 갖는 컴포넌트(Fragment)를 지원한다.

  ```
  <template>
    <div>
      <div class="input-label">
        {{inputLabel}}
      </div>
      <input type="text"/>
    </div>
  </template>
  ```

  기존 Vue2에서는 이와 같이, 루트 엘리먼트를 하나로 유지하기 위해 유지하여야 했지만,
  Vue3에서는 여러개의 루트 엘리먼트를 허용한다.

1. 차이점 : data, method 선언 방식의 변화
  Vue2에서 data, method를 선언하는 방식은 다음과 같았다.
  기존 코드에서는 props, data, methods가 같은 계층에 존재했다.

  ```
  // Vue2.x
  export default {
    props: {
      title: String
    },
    data () {
      return {
        username: '',
        password: ''
      }
    },
    methods: {
      login () {
        // login method
      }
    }
  }
  ```

  Vue3에서 바뀐 data 및 method 선언 방식은 아래와 같습니다.

  ```
  // Vue 3.x
  export default {
    props: {
      title: String
    },
    setup () {
      const state = reactive({
        username: '',
        password: ''
      })
  
      const login = () => {
        // login method
      }
      return { 
        login,
        state
      }
    }
  }
  ```

  Vue3에서는 props와 setup이 같은 계층에 존재하고, 
  setup 안에서도 data는 state로, method 들은 각각의 기명함수로 작성되어 한번에 반환되도록 변화하였다.
  state의 경우에도 그냥 선언하는 것이 아니라, vue reactive를 사용하게 되었다. 
  Reactive(반응형)는 Vue가 반응형 시스템을 유지하기 위해서 사용하는 간단한 JavaScript 객체이다.

  Vue2에서는 data나 method, computed 등을 선언하게 되면 알아서 각각에 대해 위와 같이 동작하는 reactive 객체를 생성했지만, 
  그 과정이 묵시적이었고, 유저들은 위 과정을 알 필요가 없었다. 
  반면, Vue3에서의 타입스크립트의 지원이나 state로의 명칭 변경, 명시적 reactive 사용 등을 보았을 때, 
  전반적으로 React처럼 명료한 선언을 지향하는 방향으로 변화한 것으로 보인다.

1. 차이점 : Lifecycle hook 호출의 변화
  Vue2의 lifecycle hook의 경우에 data, method와 같은 hierachy에서 선언하도록 되어 있었다.
  Vue3에서는 다른 변화들과 같이 lifecycle hook 또한 setup 내부에서 선언하도록 하였다.
  기존에 존재하던 lifecycle hook의 종류는 거의 그대로 유지된다.

  ```
  import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onActivated, onDeactivated, onErrorCaptured } from 'vue'
  
  export default {
    setup() {
      onBeforeMount(() => {
        // ... 
      })
      onMounted(() => {
        // ... 
      })
      onBeforeUpdate(() => {
        // ... 
      })
      onUpdated(() => {
        // ... 
      })
      onBeforeUnmount(() => {
        // ... 
      })
      onUnmounted(() => {
        // ... 
      })
      onActivated(() => {
        // ... 
      })
      onDeactivated(() => {
        // ... 
      })
      onErrorCaptured(() => {
        // ... 
      })
    }
  }
  ```

  이 때, const로 선언했던 기존의 state나 method들과는 달리, lifecycle hook은 return할 필요가 없다.
  이는 작성 구조만 보아도 명료하게 알 수 있다.
  각각의 함수는 실행되는 것이지 반환되는 값이나 함수 자체를 변수에 할당하는 것이 아니므로,
  따로 return하여 setup의 return으로써 포함시킬 필요가 없다.

1. 차이점 : Computed 속성 사용의 변화
  computed 속성은 이제 별도 옵션이 아닌,
  state 선언문 내에 computed 속성에 대한 선언 구문을 추가하는 방식으로 변경된다.
  기존의 computed 속성은 아래와 같이 작성하였다.

  ```
  export default {
    // ...
    computed: {
      lowerCaseUsername () {
        return this.username.toLowerCase()
      }
    }
  }
  ```

  Vue 3부터는 아래와 같이 작성한다.

  ```
  import { reactive, computed } from 'vue'
  
  export default {
    props: {
      title: String
    },
    setup () {
      const state = reactive({
        username: '',
        password: '',
        lowerCaseUsername: computed(() => state.username.toLowerCase())
      })
    }
  }
  ```

  이러한 변화에는 "사용하는 것만 import하여 사용하도록 하자"는 철학이 담겨있다.
  기존의 컴포넌트 중 computed가 필요한 컴포넌트는 상당히 소수임에도 불구하고
  모든 컴포넌트는 옵션으로써 computed를 작성하는 순간 별도의 import 없이 동작하였다.
  Vue3에서는 이러한 변화를 수정하고자 하여 computed나 lifecycle hook 등 다양한 옵션들을 함수 형태로 동작하도록 변경하였다.

1. 차이점 : Composition API
  Vue2는 Options API라는 것을 사용하고 있었다.
  Options API는 data, computed, methods 등을 사용할 수 있는 API이다.
  Options API는 굉장히 직관적이고 많은 사람들이 좋아하는 부분이었지만, 
  컴포넌트의 볼륨이 커졌을 때 유지보수가 굉장히 어려워진다는 문제를 야기했다.
  예를 들어, 큰 볼륨의 컴포넌트에서,
    state 변수(data에 선언된 변수들 등)의 선언, 
    state 변수들의 computed 메소드 바인딩,
    methods 함수 선언,
    lifecycle hook 선언
  등이 혼재해 있기 때문에, 하나의 feature에 대한 코드가 여기저기로 흩어져서, 
  볼륨이 커질 수록 유지보수가 어려워지고 논리가 어긋나기 쉬워지는 구조였다.

  Vue3에서는, 이러한 배경으로 인해, 기존의 Options API 구조를 
  가독성이 좋고 코드 안에 논리를 보존하는 방향으로 Composition API로 변경・도입하게 된다.
  (이 부분에 대해 https://github.com/vuejs/rfcs/pull/42 PR의 스레드에서 굉장히 많은 논의가 오갔었다.)    
  Composition API는 이러한 유지보수 측면에서의 문제를 해결하기 위한 해법으로 생각할 수 있다.
  아래의 예제를 바탕으로 Composition API에 대해 이해해보자.

  ```
  // Vue의 핵심 기능들을 전부 import하는 것에서, 사용하는 기능만 import 하도록 변경
  import { reactive, computed } from 'vue'
  
  export default {
    props: {
      title: String
    },

    // setup은 Composition API의 핵심 기능으로, 단어 그대로 컴포넌트의 기능들을 조립(compose)하는 역할을 한다.
    setup () {
      // 컴포넌트 내부에서 사용하기 위한 상태에 대한 값으로써 data를 선언하는 대신 state를 선언하고  reactive object로 초기화한다.
      const state = reactive({
        username: '',
        password: '',
        // 이와 같이 computed 사용, reactive 데이터바인딩 등을 할 수 있는데, 마지막에는 꼭 return해 주어야 한다.
        lowerCaseUsername: computed(() => state.username.toLowerCase())
      })
  
      // 함수를 여기에서 선언한다.
      const changeName = (name) => {
        // state 등을 호출할 때 this 바인딩이 필요하지 않게 된다.
        state.username = name
      }

      //  마지막에 setup의 return에 "state와 함수"들을 포함시켜 준다.
      return { 
        state, 
        changeName
      };
    }
  }
  ```

1. 차이점 : props와 this 바인딩의 분리
  props에 접근하는 방법도 조금 변경되었다. 
  기존에 props 뿐 아니라 method, data 등을 전부 this에 바인딩함으로써 
  코드의 가독성이 떨어지는 것을 개선하게 되었다.
  기존에는 아래와 같이 this의 하위 요소로써 prop을 직접 호출하였다.

  ```
  mounted () {
    console.log(title: ' + this.title)
  }
  ```

  그러나 위의 코드만으론 this.title 이 props의 값인지, data인지, method인지 구별할 수 없었다.
  Vue3에서 변경된 문법은 아래와 같다.

  ```
  setup (props) {
    onMounted(() => {
      console.log('title: ' + props.title)
    })
  }
  ```

  위에서 소개한 것 처럼 mounted 라이프사이클 훅은 setup 안에 포함되며, 
  setup은 props를 사용하기 위해서 props를 attribute로 받아야 한다.
  사용하는 것만 불러오도록 하는 관점과도 밀접하게 연관이 있다고 할 수 있다.

1. 차이점 : emit과 this 바인딩의 분리
  emit도 props와 마찬가지로 this에 더이상 바인드되지 않는다.
  props와 같이, setup 함수의 attribute로써 호출할 수 있다. 
  기존 코드는 아래와 같았다.

  ```
  login () {
    this.$emit('login', {
      username: this.username,
      password: this.password
    })
  }
  ```

  새로 변경된 문법에서는 아래와 같이 호출한다.

  ```
  setup (props, { emit }) {
    const login = () => {
      emit('login', {
        username: state.username,
        password: state.password
      })
    }
  }
  ```

1. 차이점 : Fragment
  Vue3에서는 루트 엘리먼트가 여러 개인 컴포넌트도 지원한다.
  기존에는 table 안에 들어가는 td 두 개를 하나의 컴포넌트로 묶어 사용하는 것 등이 불가능했다.
  특별한 문법은 없으며, 아래와 같이 그냥 기존 컴포넌트 생성하듯 생성하되 <Fragment>나 <>로 감싸 사용하면 된다.

  ```
  <>
    <td>Hello</td>
    <td>World</td>
  </>
  ```
