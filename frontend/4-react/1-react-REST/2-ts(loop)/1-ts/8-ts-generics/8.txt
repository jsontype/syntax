[TypeScript Generics]

1. TypeScript에서 Generics 사용하기
  제너릭(Generics)은 타입스크립트에서 함수, 클래스, interface, type alias를 사용하게 될 때
  여러 종류의 타입에 대하여 호환을 맞춰야 하는 상황에서 사용하는 문법이다.



1. src/practice.js 수정
  // 1. 함수에서 Generics 사용하기
  // 어떤 타입이 올지 모르는 함수를 만든다면 타입 정의를 할 때 any를 쓸 수도 있지만,
  // 결과가 any라는 것은 안에 무엇이 있는지 알 수 없다는 것이기 때문에, 
  // 타입 유추가 모두 깨진거나 다름이 없다.
  // 이런 상황에선, any 대신에 Generics를 사용하면 된다.

  // 함수에서 any를 사용 : 타입 유추가 모두 깨지며 타입 지원을 받을 수 없다.
  function wrap1(param: any): any {
    return {
      param
    }
  }
  const wrapped1 = wrap1(10) // wrapped1을 다른 곳에서 썼을 때 타입 지원을 받을 수 없다.

  // 함수에서 Generics인 <T>를 사용 : 파라미터로 다양한 타입을 넣을 수도 있고 타입 지원을 지켜낼 수 있다.
  function wrap2<T>(param: T) { // 파라미터 () 뒤에 :any 쓰는 대신, 함수명 뒤에 <T>를 설정하고, T 타입으로 된 파라미터타입을 내부에서 설정해준다.
    return {
      param
    }
  }
  const wrapped2 = wrap2(10) // wrap1처럼 아무 파라미터나 넣을 수 있으면서, wrapped2을 다른 곳에서 썼을 때 타입 지원을 받을 수 없다.



  // 1. interface에서 Generics 사용하기
  interface Items1<T> { // 인터페이스명 옆에 :any 대신 <T>을 쓰고,
    list: T[] // T 타입으로 된 배열을 내부에서 설정해준다.
  }

  const items1: Items1<string> = { // string 배열을 넣을 거라면 :string 대신 :type명<string>을 쓰고,
      list: ['a', 'b', 'c'] // string 타입으로 된 배열을 내부에서 설정해준다.
  }



  // 1. ★ type alias에서 Generics 사용하기
  type Items2<T> = { // 타입명 옆에 :any 대신 <T>을 쓰고,
      list: T[] // T 타입으로 된 배열을 내부에서 설정해준다.
  }

  const items2: Items2<string> = {// string 배열을 넣을 거라면 :any 대신 :type명<T>을 쓰고,
    list: ['a', 'b', 'c'] // string 타입으로 된 배열을 내부에서 설정해준다.
  }

  const items3: Items2<number> = {// number 배열을 넣을 거라면 :any 대신 :type명<T>을 쓰고,
    list: [1, 2, 3] // number 타입으로 된 배열을 내부에서 설정해준다.
  }



1. 테스트
    $ cd app1
    $ tsc
    app1/dist/practice.js에서 컴파일 확인
    $ node dist/practice
