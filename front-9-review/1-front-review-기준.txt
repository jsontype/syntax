[프론트엔드 리뷰 기준]

1. 기본절차
    - 오타찾기
        처음에는 가벼운 마음으로 쭉 오타를 찾아본다.
    - 질문
        변수명, 비즈니스 로직 등 모르는 것을 질문한다.
        질문받은 사람은 이를 설명하면서 다시 복기할 수 있고 질문한 사람은 답변을 보고 로직에 관한 지식을 얻는 게 목적
    - 제안
        아래의 작업 유형별로 리뷰대상을 찾고, 제안을 한다.
        "이거는 A 목적인 건가요? A 목적이 맞는다면 이렇게 해보면 어떨까요?" 정도로 자신의 가설과 제안을 함께 작성한다.
        되도록 읽는 사람이 한 번에 정보를 확인할 수 있도록 한다.



[SCSS]

1. 중복제거
    css가 중복되는 부분은 @mixin과 @include를 써서 함수화하자.



[자바스크립트]

1. 린트
    정적 분석에 걸리는 실수들은 정말 불필요하다. 기계적으로 해결가능하다
        ES Lint나 prettier 등을 활용하여 자동으로 조정 가능
        Pre-commit hook으로 등록하는 식으로 활용 가능
1. 변수/함수
    실제 서비스할때는 외부 CDN(폰트나 이미지, 라이브러리 등으로 많이 활용) 안 쓰는게 좋다. -> 스태틱 리소스로 다운받아서 사용 권장 / 이유 : 외부 CDN 장애 시 우리 서비스에도 영향이 있기 때문에
    var -> let 또는 const / 이유 : var는 중복 선언이 가능하다. var는 함수 코드블럭만 지역스코프로 인정되므로 전역변수를 남발시 문제가 될 수 있다. var는 변수 호이스팅에 의해 선언문이 스코프의 위쪽으로 끌어올려진 것 처럼 동작하며, 오류를 발생할 여지를 남긴다.
    let -> const / 이유 : 재할당이 필요한 경우에 한해 let 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다. 처음에 싹 다 const로 쓰고 바꿔야하는 값이라면 그때 let으로 바꾸는 방법도 추천한다.
    '' + '' -> `${} ${}` / 이유 : 문자열은 원래 연산 타입이 아니므로, 잠재적 오류를 없애기 위해 가급적이면 template literal을 사용하자.
    for i -> 무조건 foreach / 이유 : for i는 동적으로 컬렉션이 바뀌는 경우에 오류가 날 수 있으므로, ForEach를 쓰자. ForEach에서도 인덱스 접근 가능하다.
    DOM element 객체는 변수로 저장해놓는게 좋다.(다시 찾지 않도록) / 이유 : Js 실행시 DOM 탐색이 가장 비싼 연산이다.




[타입스크립트]

1. 인터페이스 (~/src/api/types.d.ts) : key는 키 밸류 string을 의미함
    key: string[], -> key: string[]; 또는 key: string[] / 이유 : 인터페이스는 뎁스가 없어서 세미콜론 사용하면 된다. 객체를 type과 구별하기 위해서도 콤마를 없애는 것이 필요하다.
    key: unknown -> key?: string / 이유 : unknown으로 정의하면 key 값을 사용할때 컴파일러 체크가 번거로워진다.
    key?: string | undefined | null -> key?: string / 이유 : 뒤에 undefined나 null 타입 추가보다는 옵셔널타입인 ?를 뒤에 붙이는게 좋다. 

1. 변수/함수/프로퍼티 타입지정
    :any -> :<T>[] / 이유 : 디버깅용이거나 임시용도가 아니라면 any 타입은 쓰지 않는게 좋다. 
        map, forEach 등 배열고차함수를 사용한다면 배열이므로 타입을 generics로 대체할 수 있을 것 같다. 
        또한 내용이 어떤 구조인지 알 수 있으니 interface 같은거 만들어서 지정해주는게 좋겠다.
    JSON.parse(JSON.stringify(item)) -> { ...item } 또는 Object.assign({}, item) / 이유 : 깊은 복사를 하는 거라면 JSON 함수 쓰지 않고
        { …selection } 같은 스프레드 방법으로 쓰는게 낫다. 아니면 Object.assign 함수를 써도 된다.
